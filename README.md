# DriverlessCarSimulation_Project

<div class="rendered-markdown"><h1>System Implementation</h1>
<h2>I. Meeting Chosen Solution Requirements</h2>
<p>In my System Design Proposal for a driverless car, I proposed two main classes: a parent class named DriverlessCar and a child class named SelfDrivingCar that inherits all of its attributes, but overrides the navigate method to include a self-driving mode. My System Design Proposal presented three general operations to support in my software: manual driving functions, vehicle maneuvering, and obstacle detection. I chose to implement my chosen solution requirements through the following:</p>
<p>Firstly, I ensured that my driverless car simulation is capable of manual driving operations&ndash;users are initially required to input the speed, destination, and location of the car through the terminal. The <code>DriverlessCar</code> class then allows for updating those categories through the following methods: <code>update_speed()</code>, <code>update_location()</code>, and <code>update_destination()</code>. The <code>update_speed()</code> method allows for the user’s input to be recognized as the new value of the <code>_speed</code> attribute, the <code>update_destination()</code> method takes a new destination as input and updates the <code>_destination</code> attribute. The <code>update_location()</code> method updates the current location of the car with a new location parameter, which is then added to the location history by calling <code>add_location_to_history()</code>, a list that implements a stack of strings representing locations of the car. The location is then pushed onto the end of the location queue by calling <code>push_location_to_queue()</code>. Once the user updates their chosen category, the <code>_simulate_data()</code> method updates the <code>_data</code> dictionary with the current values. <code>get_data()</code> then returns a dictionary with the car’s current speed, location, and destination.</p>
<p>In addition, I supported vehicle maneuvering and obstacle detection in my software by creating both synchronous and asynchronous methods of navigation. The <code>navigate_async()</code> method allows for the car to move from its current location to its destination asynchronously, by popping the next location from the dequeue using the <code>pop_location_from_queue()</code> method. The car moves one location at a time and prints its location. The <code>navigate()</code> method, on the other hand, simulates the car’s movement by printing status messages and waits to execute using the <code>time.sleep()</code> method to simulate the time taken by the car. In SelfDrivingCar (child class), the <code>navigate()</code> method is overridden to include a self driving mode.If an obstacle is detected or the speed limit (100mph) is exceeded, the <code>detect_obstacle()</code> and/or the <code>detect_obstacle()</code> method is then called to stop the car. In other words, if the user inputs an obstacle, <code>_obstacle_detected()</code> is flagged as True and the car comes to a stop.</p>
<h2>II. Instructions on How to Execute the Code</h2>
<p>In order to execute the code from Codio, the user will click on the OOPcode.py file and click on the Run tab. The car simulation will first demonstrate asynchronous navigation. The menu will then be displayed and the user will input the initial car data: speed (int), location (str), and destination (str).</p>
<h3>i. Update Speed</h3>
<p>The user will input “speed” when the menu is displayed. When prompted, the new speed will be entered and a dictionary containing the updated values will be returned to the user. However, if the new speed exceeds the speed limit (100), the emergency brake will be applied and the car will eventually come to a stop.</p>
<h3>ii. Update Location</h3>
<p>The user will input “location” when the menu is displayed. When prompted, the new location will be entered and a dictionary containing the updated values will be returned to the user. However, if the user inputs “obstacle” at any stage, the emergency brake will be applied and the car will eventually come to a stop.</p>
<h3>iii. Update Destination</h3>
<p>The user will input “destination” when the menu is displayed. When prompted, the new destination will be entered and a dictionary continuing the updated values will be returned to the user. However, if the user inputs “obstacle” at any stage, the emergency brake will be applied and the car will eventually come to a stop.</p>
<hr />
<h3>References</h3>
<pre><code>  1. Shi, W., &amp; Liu, L. (2021) Computing Systems for Autonomous Driving. 1st ed. Switzerland: Springer International Publishing.
  2. Serban, A., Poll, E. &amp; Visser, J. (2018) ‘A Standard Architecture for Fully Autonomous Vehicles’, 2018 IEEE International Conference on Software Architecture Companion. Seattle, Washington, 30 April- 4 May. Nijmegen: Radboud University. 120-127
</code></pre>
</div>
